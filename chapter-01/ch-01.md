# Shell Something Out
## Displaying output in a terminal
The shell supports several methods and different formats for displaying text. A shell script typically begins with a shebang:`#!/bin/bash`.
### executing a script containing shebang
1. `bash myScript.sh`
2. Set the execution permission : `chmod 755 myScript.sh` and then `./myScript.sh`.
3. Alternatively, `chmod a+x sample.sh` makes a script executable by all users.
### Types of bash
1. *logging bash*: when using SSH or logging directly to terminal. will read `.bash_profile`.
2. *Terminal*: when you logged in and open a terminal. It will read `~/.bashrc`.
### printing in Terminal: `echo`
- `echo "character"` or `echo '<character>'` adds a new line at the end of every invocation.
- `""`: takes special characters and variable expansion. Escape special characters with `\`.
- `''`: does not support special characters and expansion.
- `echo -n "string"`: disable the new line
- `echo -e "1\t2\t3"`: e flag  enables interpretation of backslash escape `\`. here `\t` interpret to `tab`.
### printing using `printf`
- printf does not append a newline.
- We have to specify a newline when required
- The `%s, %c, %d, and %f` characters are *format substitution characters*
- The `%-5s` string defines a string substitution with left alignment (- represents left alignment) and a 5 character width. If - was not specified, the string would have been aligned to the right.
- The width specifies the number of characters reserved for the string.
- in the following example, For `Name`, the width reserved is 10. Hence, any name will reside within the 10-character width reserved for it and the rest of the line will be filled with spaces up to 10 characters total.
- `%-4.2f`:width is 4, and .2 specifies rounding off to two decimal places

```
#!/bin/bash
#Filename: printf.sh

printf  "%-5s %-10s %-4s\n" No Name  Mark
printf  "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456
printf  "%-5s %-10s %-4.2f\n" 2 James 90.9989
printf  "%-5s %-10s %-4.2f\n" 3 Jeff 77.564
```

The formatted output is:

```
No    Name       Mark
1     Sarath     80.35
2     James      91.00
3     Jeff       77.56
```

## Using variables and environment variables
To see a list of environment variable `env` or `printenv`

### view the environment of other processes:
 `cat /proc/$PID/environ`. replace the PID with the integer. get the PID using `pgrep ProcccessName`. var=value pairs are separated by *null character* `\0`. To make the output human readable: `cat /proc/12501/environ | tr '\0' '\n'`.
### define variables
- An equal sign without spaces is an assignment operation: `varName=value`
- whereas using spaces creates an equality test `var = value`
- access the content of var: `echo ${var}` or `echo $var`
- using vars in echo: `fruit=apple; count=5; echo "We have $count ${fruit}(s)"`' We use ${} to tell shell that the var name is fruit not fruit(s).'
### define and export environment variable
We define env var and export it: `HTTP_PROXY=192.168.1.23:3128; export HTTP_PROXY`. The `export` command declares one or more variables that will be inherited by child tasks. After variables are exported, any application executed from the *current shell script*, receives this variable.
- Usually, `$PATH` is defined in `/etc/environment, /etc/profile or ~/.bashrc`.
- To prepend something to PATH: `export PATH="$PATH:/home/user/bin"` or `export PATH=/opt/myapp/bin:$PATH`
- to prepend `lib` folder of you new app: `export LD_LIBRARY_PATH=/opt/myapp/lib;$LD_LIBRARY_PATH`
- or define this  function in `~/.bashrc`: `prepend() { [ -d "$2" ] && eval $1=\"$2':'\$$1\" && export $1; }` and  use it as: `prepend PATH /opt/myapp/bin`
### Get the length of a variable's value `${#var}`
`var=12345678901234567890$; length=${#var}` will print 20.

### Checking for super user
The `UID` environment variable holds the User ID. Use this value to check whether the current script is being run as a root user or regular user. The `UID` value for the root user is 0.

```Shell
If [ $UID -ne 0 ]; then
  echo Non root user. Please run as root.
else
  echo Root user
fi
```
## Math with the shell
The Bash shell performs basic arithmetic operations using the `let`, `(( ))`, and `[]` commands. The `expr` and `bc` utilities are used to perform advanced operations.
### Using `let`
Within a let command, we use variable names without the $ prefix.

```Shell
no1=4; no2=5
let result=no1+no2
echo $result

let no1++; let no+=6 # increment variable in place
let no1--; let no-=6   # decrement variable in place
```
### Using `[]`, `(())` or `expr` operator
These methods  work for integers only.

```Shell
no1=4; no2=5
result=$[ no1 + no2 ]
result=$[ $no1 + 5 ]
result=$(( no1 + 50 ))
result=`expr 3 + 4`
result=$(expr $no1 + 5)
 ```
### using `bc`
This is a more advanced function capable of performing operations on floating points.

```Shell
echo "4 * 0.56" | bc
2.24
no=54;
result=`echo "$no * 1.5" | bc`
echo $result
81.0
```

The bc application accepts prefixes to control the operation. These are separated from each other with a semicolon.
```Shell
echo "scale=2;22/7" | bc  #scale define decimal of output (3.14)
echo "sqrt(100)" | bc #Square root
echo "10^10" | bc #Square  |  
```
## Playing with file descriptors and redirection
**File descriptors** are integers associated with an opened file or data stream that are 0, 1, and 2 associated with `stdin, stdout, stderr`
- stdout overwrite: `echo "This is a sample text 1" > temp.txt`
- stdout append: `echo "This is sample text 2" >> temp.txt`
- The return status is available in the special variable `$?`
- `2>`: redirect stderr
- `2>&1` or `&>` stderr and stdout to a single file
- To send two copies of the input to stdout, use `-` for the filename argument:

  ```
  echo who is this | tee -
  who is this
  who is this
  ```

The `tee` command reads only from stdin:

```Shell
command | tee FILE1 FILE2 | otherCommand
echo A1 > a1; echo A2 > a2; echo A3 > a3;
chmod 000 a1  #Deny all permissions
cat a* | tee out.txt | cat -n  #-n: add row number; overwrite out.txt
cat a* | tee -a out.txt | cat -n #append out.txt
```
